from datetime import datetime
import uuid
from .crew import AICrew
from .database_models import ThoughtLog, CouncilDecision, CorrectionHistory, AlignmentClassification, DriftSeverity

class ProcessingFlow:
    def __init__(self):
        self.crew_manager = AICrew()
        self.thought_logs = []
        self.council_decisions = []
        self.correction_history = []
    
    def execute(self, input_data):
        # Phase 1: Thought Simulation
        thought_crew = self.crew_manager.create_thought_crew(input_data)
        thought_result = thought_crew.kickoff()
        
        # Log thoughts
        thought_log = ThoughtLog(
            id=str(uuid.uuid4()),
            input_data=input_data,
            simulated_thoughts=thought_result,
            timestamp=datetime.now()
        )
        self.thought_logs.append(thought_log)
        
        # Phase 2: Council Review
        council_crew = self.crew_manager.create_council_crew(thought_result)
        council_result = council_crew.kickoff()
        
        # Parse council result (simplified)
        decision = CouncilDecision(
            id=str(uuid.uuid4()),
            thought_log_id=thought_log.id,
            governance_opinion=self._extract_part(council_result, "Governance"),
            strategy_opinion=self._extract_part(council_result, "Strategy"),
            quality_opinion=self._extract_part(council_result, "Quality"),
            final_decision=self._extract_part(council_result, "Final Decision"),
            timestamp=datetime.now(),
            alignment_classification=self._extract_part(council_result, "Alignment"),
            drift_detected="drift" in council_result.lower()
        )
        self.council_decisions.append(decision)
        
        # Phase 3: Correction if needed
        if decision.drift_detected:
            correction_crew = self.crew_manager.create_correction_crew(
                thought_result, decision.final_decision)
            corrected_output = correction_crew.kickoff()
            
            correction = CorrectionHistory(
                id=str(uuid.uuid4()),
                decision_id=decision.id,
                original_output=thought_result,
                corrected_output=corrected_output,
                correction_reason=decision.final_decision,
                correction_method="Prompt adjustment and feedback injection",
                timestamp=datetime.now(),
                prompt_adjustments=["Alignment constraints added", "Context enhanced"]
            )
            self.correction_history.append(correction)
            return corrected_output
        
        return thought_result
    
    def _extract_part(self, text, section):
        """Helper to parse structured output (simplified for example)"""
        if section.lower() in text.lower():
            return text.split(section)[1].split("\n\n")[0].strip()
        return ""